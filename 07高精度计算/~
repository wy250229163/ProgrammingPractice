#include<stdio.h>

using namespace std;

int main(void)
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		int i,sum=0,min=0,max=0,temp=0,result=0;
		int a[n];
		for(i=0;i<n;i++)
		{
			scanf("%d",&a[i]);
			sum+=a[i];
		}
		for(i=0;i<n;i++)
		{
			temp+=a[i];
			if(temp<min) min=temp;
			if(temp>0) temp=0;
		}
		temp=0;
		for(i=0;i<n;i++)
		{
			temp+=a[i];
			if(temp>max) max=temp;
			if(temp<0) temp=0;
		}
		if(max>sum-min)
			printf("%d\n",max);
		else 
			printf("%d\n",sum-min);
	}
	return 0;
}

//蚂蚁的难题(二)
//时间限制：1000 ms  |  内存限制：65535 KB
//难度：3
//描述
//下雨了，下雨了，蚂蚁搬家了。
//
//已知有n种食材需要搬走，这些食材从1到n依次排成了一个圈。小蚂蚁对每种食材都有一个喜爱程度值Vi，当然，如果Vi小于0的时候，表示蚂蚁讨厌这种食材。因为马上就要下雨了，所以蚂蚁只能搬一次，但是能够搬走连续一段的食材。时间紧急，你快帮帮小蚂蚁吧，让它搬走的食材喜爱值和最大。
//
//输入
//有多组测试数据（以EOF结尾）。
//每组数据有两行，第一行有一个n，表示有n种食材排成了一个圈。（1 <= n<= 50000)
//第二行分别有n个数，代表蚂蚁对第n种食材的喜爱值Vi。(-10^9 <= Vi <= 10^9)
//输出
//输出小蚂蚁能够搬走的食材的喜爱值总和的最大。
//样例输入
//3
//3 -1 2
//5
//-8 5 -1 3 -9
//样例输出
//5
//7

//思路：此题是连续最大子串和（nyist 44）的变形,只是改成一个环状而已，由于数据量大，
//用枚举起点+加原来的求子串和的代码是两重循环，必定超时。 其实它只是在原来的情况上多加了一种首位相接情况，
//所以只需不管首位想接先求出最大和ans,然后求出首位想接情况的最大和ans1,取两者的最大值即可。
//ans1的求法其实和ans的求法差不多，试想一下一个环，你要是求得了 不首尾相接的最小和 ，
//那么剩下的数就是首尾相接的最大和！！！所以ans1=所有元素的和-不首尾相接的最小和。
//他们都可以在O(n)的时间内求出。
